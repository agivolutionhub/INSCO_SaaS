from fastapi import FastAPI, HTTPException, BackgroundTasks, UploadFile, File, Form, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, Response, JSONResponse
from pydantic import BaseModel, Field
from pathlib import Path
import sys, os
import uuid
import shutil
import json
import io
import zipfile
from typing import List, Dict, Optional, Any
from rich.console import Console
import time

# Consola para logs
console = Console()

# Obtener el directorio base
BASE_DIR = Path(__file__).resolve().parent

# Añadir directorio de scripts al path
sys.path.insert(0, str(BASE_DIR))

# Importar los scripts necesarios
from services.autofit_service import procesar_pptx, procesar_lote
from scripts.snapshot import extract_pptx_slides
from scripts.transcript import transcribe_video
from scripts.video_cut import cut_video, format_time_for_ffmpeg
from scripts.video_montage import generate_video_montage
from scripts.text_to_speech import generate_speech_from_file

# Importar routers
from routes.translate_pptx import router as translate_pptx_router
from routes.split_pptx import router as split_pptx_router
from routes.snapshot import router as snapshot_router
from routes.autofit import router as autofit_router
from routes.transcript import router as transcript_router
from routes.text_to_speech import router as text_to_speech_router

# Crear una instancia de FastAPI
app = FastAPI(title="INSCO API")

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],  # Frontend Vite
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Incluir routers
app.include_router(translate_pptx_router)
app.include_router(split_pptx_router)
app.include_router(snapshot_router)
app.include_router(autofit_router)
app.include_router(transcript_router)
app.include_router(text_to_speech_router)

# Crear directorios temporales para archivos subidos y procesados
UPLOAD_DIR = BASE_DIR / "tmp/uploads"
PROCESSED_DIR = BASE_DIR / "tmp/processed"
CAPTURES_DIR = BASE_DIR / "tmp/captures"
AUDIO_DIR = BASE_DIR / "tmp/audio"
TRANSCRIPTS_DIR = BASE_DIR / "storage/transcripts"
VIDEO_DIR = BASE_DIR / "tmp/videos"
AUDIO_OUTPUT_DIR = BASE_DIR / "storage/audio"

# Configurar variables de entorno para que las rutas puedan acceder a estos directorios
os.environ["CAPTURES_DIR"] = str(CAPTURES_DIR)

# Crear directorios
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
PROCESSED_DIR.mkdir(parents=True, exist_ok=True)
CAPTURES_DIR.mkdir(parents=True, exist_ok=True)
AUDIO_DIR.mkdir(parents=True, exist_ok=True)
TRANSCRIPTS_DIR.mkdir(parents=True, exist_ok=True)
VIDEO_DIR.mkdir(parents=True, exist_ok=True)
AUDIO_OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

@app.get("/")
async def root():
    return {"message": "INSCO API está funcionando"}

# Endpoints de compatibilidad para mantener URLs antiguas
@app.post("/api/upload-video-for-transcription")
async def legacy_upload_video_for_transcription(
    file: UploadFile = File(...),
    background_tasks: BackgroundTasks = None
):
    """
    Endpoint de compatibilidad para mantener la URL antigua.
    Sube un archivo de video para transcripción.
    """
    try:
        # Validar archivo
        if not file.filename or not file.filename.lower().endswith((".mp4", ".mov", ".avi", ".webm", ".mkv")):
            raise HTTPException(status_code=400, detail="El archivo debe ser un vídeo compatible (.mp4, .mov, .avi, .webm, .mkv)")
        
        # Generar ID único
        file_id = str(uuid.uuid4())
        original_name = Path(file.filename).stem
        file_extension = Path(file.filename).suffix.lower()
        
        # Asegurar que directorio existe
        VIDEO_DIR.mkdir(parents=True, exist_ok=True)
        
        # Guardar archivo en VIDEO_DIR (importante)
        file_path = VIDEO_DIR / f"{file_id}{file_extension}"
        
        console.print(f"[green]Guardando archivo '{file.filename}' como '{file_path}'")
        
        with open(file_path, "wb") as f:
            shutil.copyfileobj(file.file, f)
        
        # Verificar que el archivo se guardó correctamente
        if not file_path.exists():
            console.print(f"[red]Error: El archivo no se guardó correctamente en {file_path}")
            raise HTTPException(status_code=500, detail="Error al guardar el archivo")
        
        console.print(f"[green]Archivo guardado exitosamente como {file_path}")
        console.print(f"[green]file_id: {file_id}, original_name: {original_name}")
        
        # Lista de archivos en VIDEO_DIR para depuración
        files_in_dir = list(VIDEO_DIR.glob("*"))
        console.print(f"[green]Archivos en {VIDEO_DIR}: {[f.name for f in files_in_dir]}")
        
        # Devolver respuesta con la misma estructura que espera el frontend
        return {
            "file_id": file_id,
            "filename": file.filename,
            "original_name": original_name,
            "status": "uploaded",
            "file_path": str(file_path)
        }
    except Exception as e:
        console.print(f"[red]Error en upload_video_for_transcription: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error al procesar la carga del archivo: {str(e)}")

@app.post("/api/process-video-transcription")
async def legacy_process_video_transcription(
    file_id: str = Form(...),
    original_name: str = Form(None),
    model_name: str = Form("gpt-4o-transcribe"),
    formats: str = Form("txt,json"),
    background_tasks: BackgroundTasks = None
):
    """
    Endpoint de compatibilidad para mantener la URL antigua.
    Redirige a la nueva implementación en el router de transcripción.
    """
    from routes.transcript import process_video
    return await process_video(
        file_id=file_id,
        original_name=original_name,
        model_name=model_name,
        formats=formats,
        background_tasks=background_tasks
    )

@app.get("/api/transcription-status/{job_id}")
async def legacy_transcription_status(job_id: str):
    """
    Endpoint de compatibilidad para mantener la URL antigua.
    Verifica el estado de un trabajo de transcripción.
    """
    try:
        console.print(f"[green]Verificando estado de transcripción para job_id: {job_id}")
        
        # Verificar resultado en archivo
        result_file = TRANSCRIPTS_DIR / f"{job_id}_result.json"
        console.print(f"[yellow]Buscando archivo de resultado: {result_file}")
        
        if result_file.exists():
            console.print(f"[green]Archivo de resultado encontrado: {result_file}")
            try:
                with open(result_file, "r", encoding="utf-8") as f:
                    result = json.load(f)
                console.print(f"[green]Resultado cargado correctamente: estado={result.get('status', 'desconocido')}")
                
                # Expandir el resultado para añadir URLs de archivos si faltan
                if 'files' in result and isinstance(result['files'], dict):
                    files_list = []
                    for fmt, path in result['files'].items():
                        if isinstance(path, str):
                            path_obj = Path(path)
                            url = f"/api/download-transcript/{job_id}/{path_obj.name}"
                            files_list.append({
                                "format": fmt,
                                "url": url,
                                "description": f"Archivo {fmt.upper()}"
                            })
                    
                    # Reemplazar el diccionario de files por la lista esperada por el frontend
                    if files_list:
                        result['files'] = files_list
                
                return result
            except Exception as e:
                console.print(f"[red]Error al leer resultado: {str(e)}")
                import traceback
                traceback.print_exc()
                return {
                    "job_id": job_id, 
                    "status": "error", 
                    "message": f"Error al leer resultado: {str(e)}"
                }
        
        # Verificar en trabajos activos
        from routes.transcript import active_jobs
        console.print(f"[yellow]Buscando en trabajos activos. Trabajos actuales: {list(active_jobs.keys())}")
        
        if job_id in active_jobs:
            console.print(f"[green]Trabajo encontrado en lista de activos")
            elapsed = time.time() - active_jobs[job_id].get("start_time", 0)
            return {
                "job_id": job_id, 
                "status": "processing",
                "elapsed_time": f"{elapsed:.1f}s",
                "file_id": active_jobs[job_id].get("file_id", "")
            }
        
        # Si llegamos aquí, el trabajo no existe
        console.print(f"[red]Trabajo no encontrado: {job_id}")
        
        # Buscar archivos relacionados con este job_id en el sistema de archivos
        job_dir = TRANSCRIPTS_DIR / job_id
        if job_dir.exists():
            files = list(job_dir.glob("*"))
            console.print(f"[yellow]Se encontró directorio del trabajo pero sin archivo de resultado. Contenido: {[f.name for f in files]}")
        
        return {
            "job_id": job_id, 
            "status": "not_found",
            "message": "El trabajo de transcripción no existe o ha expirado"
        }
    except Exception as e:
        console.print(f"[red]Error al verificar estado de transcripción: {str(e)}")
        import traceback
        traceback.print_exc()
        return {
            "job_id": job_id,
            "status": "error",
            "message": f"Error al verificar estado: {str(e)}"
        }

@app.get("/api/download-transcript/{job_id}/{filename}")
async def legacy_download_transcript(job_id: str, filename: str):
    """Endpoint para descargar archivos de transcripción."""
    try:
        console.print(f"[green]Solicitud de descarga: job_id={job_id}, filename={filename}")
        
        # Buscar en múltiples ubicaciones posibles
        possible_paths = [
            TRANSCRIPTS_DIR / job_id / filename,  # Estructura job_id/filename
            TRANSCRIPTS_DIR / filename,           # Directamente en TRANSCRIPTS_DIR
        ]
        
        # Buscar en todas las ubicaciones posibles
        for file_path in possible_paths:
            if file_path.exists():
                console.print(f"[green]Archivo encontrado: {file_path}")
                
                # Determinar el tipo de contenido basado en la extensión
                if filename.endswith('.json'):
                    media_type = "application/json"
                elif filename.endswith('.txt'):
                    media_type = "text/plain"
                elif filename.endswith('.md'):
                    media_type = "text/markdown"
                else:
                    media_type = "application/octet-stream"
                
                return FileResponse(
                    path=file_path,
                    filename=filename,
                    media_type=media_type
                )
        
        # Si llegamos aquí, no se encontró el archivo
        console.print(f"[red]Archivo no encontrado en ninguna ubicación: {job_id}/{filename}")
        return JSONResponse(
            {"status": "error", "message": "Archivo no encontrado"}, 
            status_code=404
        )
    except Exception as e:
        console.print(f"[red]Error al descargar archivo: {str(e)}")
        import traceback
        traceback.print_exc()
        return JSONResponse(
            {"status": "error", "message": f"Error al descargar: {str(e)}"}, 
            status_code=500
        )

@app.post("/api/transcribe-video")
async def legacy_transcribe_video(
    file_id: str = Form(...),
    original_name: str = Form(None),
    model_name: str = Form("gpt-4o-transcribe"),
    formats: str = Form("txt,json"),
    background_tasks: BackgroundTasks = None
):
    """Endpoint de transcripción directa sin complicaciones."""
    try:
        console.print(f"[green]Iniciando transcripción para archivo_id: {file_id}")
        
        # Buscar el archivo
        file_path = None
        for directory in [VIDEO_DIR, UPLOAD_DIR]:
            files = list(directory.glob(f"{file_id}.*"))
            if files:
                file_path = files[0]
                break
        
        if not file_path:
            raise HTTPException(status_code=404, detail=f"Archivo con ID {file_id} no encontrado")
        
        console.print(f"[green]Archivo encontrado: {file_path}")
        
        # Configurar formatos
        formats_list = formats.split(",") if formats else ["txt", "json"]
        
        # Usar directamente el servicio de transcripción
        from services.transcript_service import transcribe_video
        
        # Crear directorio para la salida
        output_dir = TRANSCRIPTS_DIR / file_id
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Llamar directamente al servicio (modo síncrono)
        console.print(f"[green]Iniciando transcripción real...")
        result = transcribe_video(
            video_path=file_path,
            output_dir=output_dir,
            model_name=model_name,
            formats=formats_list,
            original_name=original_name,
            silent=False
        )
        
        console.print(f"[green]Transcripción completada con éxito")
        
        # Crear una respuesta en formato compatible con frontend
        response = {
            "job_id": file_id,
            "text": result.get("text", ""),
            "segments": result.get("segments", []),
            "stats": result.get("stats", {}),
            "status": "completed",
            "files": []
        }
        
        # Añadir URLs para descargar archivos
        for fmt, path_str in result.get("files", {}).items():
            path = Path(path_str)
            response["files"].append({
                "format": fmt,
                "url": f"/api/download-transcript/{file_id}/{path.name}",
                "description": f"Archivo {fmt.upper()}"
            })
        
        return response
    except Exception as e:
        console.print(f"[red]Error en transcripción: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error al transcribir video: {str(e)}")

@app.post("/api/update-transcription")
async def update_transcription(request: Request):
    """
    Endpoint para actualizar una transcripción existente con correcciones manuales.
    """
    try:
        data = await request.json()
        file_id = data.get("file_id")
        original_name = data.get("original_name")
        text = data.get("text")
        segments = data.get("segments", [])
        
        if not file_id or not text:
            raise HTTPException(status_code=400, detail="Se requiere file_id y texto corregido")
        
        console.print(f"[green]Actualizando transcripción para file_id: {file_id}")
        
        # Crear un directorio para la transcripción actualizada
        update_id = str(uuid.uuid4())
        update_dir = TRANSCRIPTS_DIR / update_id
        update_dir.mkdir(parents=True, exist_ok=True)
        
        # Guardar el texto corregido
        txt_path = update_dir / f"{original_name or 'transcripcion_corregida'}.txt"
        with open(txt_path, "w", encoding="utf-8") as f:
            f.write(text)
        
        # Guardar la versión JSON con segmentos
        json_path = update_dir / f"{original_name or 'transcripcion_corregida'}.json"
        with open(json_path, "w", encoding="utf-8") as f:
            json.dump({
                "text": text,
                "segments": segments,
                "file_id": file_id,
                "original_name": original_name,
                "update_time": time.time()
            }, f, ensure_ascii=False, indent=2)
        
        # Generar respuesta con URLs para descargar los archivos
        return {
            "status": "success",
            "message": "Transcripción actualizada correctamente",
            "files": [
                {
                    "format": "txt",
                    "url": f"/api/download-transcript/{update_id}/{txt_path.name}",
                    "description": "Texto plano"
                },
                {
                    "format": "json",
                    "url": f"/api/download-transcript/{update_id}/{json_path.name}",
                    "description": "JSON con segmentos"
                }
            ]
        }
    except Exception as e:
        console.print(f"[red]Error al actualizar transcripción: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error al actualizar transcripción: {str(e)}")

@app.post("/api/improve-text")
async def improve_text(request: Request):
    """
    Endpoint para mejorar fragmentos de texto usando IA.
    """
    try:
        data = await request.json()
        text = data.get("text")
        context = data.get("context", "")
        segment_id = data.get("segment_id", -1)
        
        if not text:
            raise HTTPException(status_code=400, detail="Se requiere texto para mejorar")
        
        console.print(f"[green]Mejorando texto con IA: {text[:50]}...")
        
        # Aquí normalmente llamaríamos a un servicio de IA para mejorar el texto
        # Por ahora, simularemos una respuesta para mantener la compatibilidad
        improved_text = text  # En una implementación real, esto sería el texto mejorado por IA
        
        # Simular costo para propósitos de compatibilidad
        input_tokens = len(text.split()) + len(context.split())
        output_tokens = len(improved_text.split())
        
        return {
            "original_text": text,
            "improved_text": improved_text,
            "is_improved": False,  # Indicar que no hubo mejoras reales
            "segment_id": segment_id,
            "tokens": {
                "prompt": input_tokens,
                "completion": output_tokens,
                "total": input_tokens + output_tokens
            },
            "cost": {
                "input_cost": input_tokens * 0.00001,
                "output_cost": output_tokens * 0.00003,
                "total_cost": (input_tokens * 0.00001) + (output_tokens * 0.00003)
            }
        }
    except Exception as e:
        console.print(f"[red]Error al mejorar texto: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error al mejorar texto: {str(e)}")

@app.post("/api/improve-multiple-sentences")
async def improve_multiple_sentences(request: Request):
    """
    Endpoint para mejorar múltiples oraciones usando IA.
    """
    try:
        data = await request.json()
        sentences = data.get("sentences", [])
        context = data.get("context", "")
        
        if not sentences:
            raise HTTPException(status_code=400, detail="Se requieren oraciones para mejorar")
        
        console.print(f"[green]Mejorando {len(sentences)} oraciones con IA...")
        
        # Aquí normalmente llamaríamos a un servicio de IA para mejorar cada oración
        # Por ahora, simularemos una respuesta para mantener la compatibilidad
        results = []
        for sentence in sentences:
            results.append({
                "id": sentence.get("id", 0),
                "original_text": sentence.get("text", ""),
                "improved_text": sentence.get("text", ""),  # Sin cambios en esta simulación
                "is_improved": False
            })
        
        # Simular costo total
        input_tokens = len(context.split()) + sum(len(s.get("text", "").split()) for s in sentences)
        output_tokens = sum(len(s.get("text", "").split()) for s in sentences)
        
        return {
            "results": results,
            "tokens": {
                "prompt": input_tokens,
                "completion": output_tokens,
                "total": input_tokens + output_tokens
            },
            "cost": {
                "input_cost": input_tokens * 0.00001,
                "output_cost": output_tokens * 0.00003,
                "total_cost": (input_tokens * 0.00001) + (output_tokens * 0.00003)
            }
        }
    except Exception as e:
        console.print(f"[red]Error al mejorar múltiples oraciones: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error al mejorar múltiples oraciones: {str(e)}")

@app.post("/api/upload-pptx-for-captures")
async def upload_pptx_for_captures(file: UploadFile = File(...)):
    try:
        file_id = str(uuid.uuid4())
        filename = file.filename
        original_name = Path(filename).stem
        file_extension = Path(filename).suffix
        
        if file_extension.lower() != '.pptx':
            raise HTTPException(status_code=400, detail="Solo se permiten archivos PPTX")
        
        UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
        
        file_location = UPLOAD_DIR / f"{file_id}{file_extension}"
        
        with open(file_location, "wb") as f:
            shutil.copyfileobj(file.file, f)
        
        if not file_location.exists():
            raise HTTPException(status_code=500, detail=f"Error: No se pudo guardar el archivo en {file_location}")
        
        return {
            "file_id": file_id,
            "filename": filename,
            "original_name": original_name,
            "file_path": str(file_location)
        }
    except Exception as e:
        console.print(f"Error en upload_pptx_for_captures: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error al procesar la carga del archivo: {str(e)}")

@app.post("/api/process-captures")
async def process_captures(file_id: str = Form(...), original_name: str = Form(None)):
    try:
        files = list(UPLOAD_DIR.glob(f"{file_id}.*"))
        
        if not files:
            raise HTTPException(status_code=404, detail="Archivo no encontrado")
        
        file_path = files[0]
        
        capture_dir = CAPTURES_DIR / file_id
        capture_dir.mkdir(parents=True, exist_ok=True)
        
        try:
            stats = extract_pptx_slides(
                pptx_path=file_path,
                output_dir=capture_dir,
                format="png",
                dpi=300
            )
            
            # Crear URLs correctas para acceder a las imágenes
            image_urls = []
            for img_path in sorted(capture_dir.glob("*.png")):
                # En lugar de usar rutas relativas, usar endpoint específico para servir los archivos
                slide_name = img_path.name
                image_urls.append(f"/api/snapshot/files/{file_id}/{slide_name}")
            
            return {
                "status": "success",
                "file_id": file_id,
                "original_name": original_name or Path(file_path).stem,
                "slides_count": stats["slides"],
                "image_urls": image_urls
            }
            
        except Exception as e:
            import traceback
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=f"Error al generar capturas: {str(e)}")
            
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error al procesar el archivo: {str(e)}")

@app.get("/api/download/{filename}")
async def download_file(filename: str):
    file_path = PROCESSED_DIR / filename
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Archivo no encontrado")
    
    return FileResponse(
        path=file_path,
        media_type="application/vnd.openxmlformats-officedocument.presentationml.presentation",
        filename=filename
    )

# Punto de entrada para ejecutar la aplicación
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8088, reload=True)

# Modelo para solicitudes de descarga de ZIP
class ZipRequest(BaseModel):
    image_urls: List[str]
    original_name: Optional[str] = "capturas"

@app.post("/api/download-captures-zip")
async def download_captures_zip(request: ZipRequest):
    try:
        image_urls = request.image_urls
        original_name = request.original_name
        
        if not image_urls:
            raise HTTPException(status_code=400, detail="No se proporcionaron URLs de imágenes")
        
        console.print(f"Generando ZIP con {len(image_urls)} imágenes")
        
        # Crear un archivo ZIP en memoria
        zip_buffer = io.BytesIO()
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for i, url in enumerate(image_urls, 1):
                # Extraer el ID del directorio y el nombre del archivo de la URL
                # Las URLs tienen formato /api/snapshot/files/{dir_id}/{filename}
                parts = url.strip('/').split('/')
                if len(parts) >= 5:
                    dir_id = parts[-2]
                    filename = parts[-1]
                    
                    # Buscar primero en storage/snapshots
                    snapshot_path = BASE_DIR / "storage/snapshots" / dir_id / filename
                    capture_path = CAPTURES_DIR / dir_id / filename
                    
                    if snapshot_path.exists():
                        image_path = snapshot_path
                    elif capture_path.exists():
                        image_path = capture_path
                    else:
                        console.print(f"[yellow]Advertencia: Imagen no encontrada: {url}")
                        continue
                    
                    console.print(f"Añadiendo imagen: {image_path}")
                    zip_file.write(image_path, arcname=f"diapositiva_{i:03d}.png")
                else:
                    console.print(f"[yellow]URL de imagen con formato incorrecto: {url}")
        
        # Preparar el buffer para lectura
        zip_buffer.seek(0)
        
        # Limpiar el nombre original para evitar problemas con caracteres especiales
        safe_name = ''.join(c for c in original_name if c.isalnum() or c in ('_', '-', '.'))
        
        # Crear respuesta con el archivo ZIP
        return Response(
            content=zip_buffer.getvalue(),
            media_type="application/zip",
            headers={
                "Content-Disposition": f'attachment; filename="{safe_name}_capturas.zip"'
            }
        )
    except Exception as e:
        console.print(f"[red]Error al crear archivo ZIP: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error al crear archivo ZIP: {str(e)}") 